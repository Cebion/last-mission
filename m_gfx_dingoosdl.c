/*

	SDL video backend for handheld consoles
	Screen resolutions:
		320x240x16 for Dingoo A320 (Native OS, Dingux, OpenDingux), GP32, Wiz or Caanoo UNTESTED
		400x240x16 for Dingoo A380 (uses Dingux variant) UNTESTED
		480x272x16 for Ritmix RZX-50 (R480) (uses Dingux variant)
	For the last one, the A320 compatibility mode is shitty, do screen centering ourselves
*/

#include "m_core.h"
#include "m_gfx.h"
#include "SDL/SDL.h"

// forward def of palette in RGBA format
extern unsigned char pal256[1024];

// forward def of pallette in 565 format
extern unsigned short pal565[];

unsigned char Keys[128] = {0};

int LM_GFX_Init();
void LM_GFX_Deinit();

SDL_Surface *small_screen = NULL;
SDL_Surface *screen = NULL;

#if defined(__DINGUX__)
int VMode = 0; // 0 - 320x240, 1 - 400x240, 2 - 480x272
int StretchFullScreen = 0; // 0 - no stretch, 1 - bilinear stretch
#define NUMOFVIDEOMODES 3
struct {
	int x;
	int y;
} VModes[NUMOFVIDEOMODES] = {
	{320, 240},
	{400, 240},
	{480, 272}
};
#endif

//===============================================================
void LM_ResetKeys()
{
	memset(&Keys[0], 0, 128);
}

int LM_AnyKey()
{
	for(int i = 0; i < 127; i++)
	{
		if(Keys[i] == 1) return 1;
	}
	return 0;
}

int LM_Timer()
{
	return SDL_GetTicks();
}

void LM_Sleep(int sleep_time)
{
	SDL_Delay(sleep_time);
}

int LM_Init(unsigned char **pScreenBuffer)
{
	if(LM_GFX_Init() == 0) return 0;

	*pScreenBuffer = (unsigned char *)small_screen->pixels;
	return 1;
}

void LM_Deinit()
{
	LM_GFX_Deinit();
}

char LM_PollEvents()
{
	SDL_Event event;

	while (SDL_PollEvent(&event) != 0)
	{
		int key_scan = -1;
		unsigned char key_value = 0;

		if(event.type == SDL_QUIT) {Keys[SC_ESCAPE] = 1; return 1; }

		// dingoo sdl doesn't have scancode, so remap usual keys
		if(event.type == SDL_KEYDOWN) key_value = 1;
		if(event.type == SDL_KEYUP) key_value = 0;

		// Emulate x86 scancodes
		if(event.type == SDL_KEYDOWN || event.type == SDL_KEYUP)
		{
			switch(event.key.keysym.sym)
			{
				case SDLK_UP:
					key_scan = SC_UP;
					break;
				case SDLK_DOWN:
					key_scan = SC_DOWN;
					break;
				case SDLK_LEFT:
					key_scan = SC_LEFT;
					break;
				case SDLK_RIGHT:
					key_scan = SC_RIGHT;
					break;
				case SDLK_ESCAPE:	// SELECT button
					key_scan = SC_ESCAPE;
					break;
				case SDLK_RETURN:	// START button
					key_scan = SC_ENTER;
					break;
				case SDLK_LCTRL:	// A button
				case SDLK_LALT:		// B button
				case SDLK_LSHIFT:	// Y button
				case SDLK_SPACE:	// X button
				case SDLK_PAUSE:
					key_scan = SC_SPACE;
					break;
				case SDLK_TAB: // LEFT SHOULDER
					key_scan = SC_TAB;
					break;
				case SDLK_BACKSPACE: // RIGHT SHOULDER
					key_scan = SC_BACKSPACE;
					break;
				default:;
					break;
			}
			if(key_scan != -1) Keys[key_scan] = key_value;
		}
	}

	// turn on/off fullscreen upscaling
	#if defined(__DINGUX__)
	if(Keys[SC_TAB] == 1)
	{
		if(++StretchFullScreen > 2)	StretchFullScreen = 0;
		Keys[SC_TAB] = 0;
		memset(screen->pixels, 0, VModes[VMode].x * VModes[VMode].y * 2);
	}
	#endif

	return 0;
}

int LM_GFX_Init()
{
	// Ignore pressing X for exit to OS
	SDL_putenv("DINGOO_IGNORE_OS_EVENTS=1");

	// Start SDL, other parameters will not do
	if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_AUDIO) < 0) return 0;
	atexit(SDL_Quit);

	// Probe video modes sequentially - first 480x272, then 400x240 and then 320x240
	// All because dingux can be run on different handhelds (A320, A380, RZX-50)
	#if defined(__DINGUX__)
	for(VMode = NUMOFVIDEOMODES-1; VMode >= 0; VMode--)
	{
		if(SDL_VideoModeOK(VModes[VMode].x, VModes[VMode].y, 16, SDL_SWSURFACE) != 0)
		{
			screen = SDL_SetVideoMode(VModes[VMode].x, VModes[VMode].y, 16, SDL_SWSURFACE);
			break;
		}
	}

	#elif defined(__DINGOO__)
	// Set up screen, strictly 320 x 240 x 16 software surface
	screen = SDL_SetVideoMode(320, 240, 16, SDL_SWSURFACE);
	#else
	#error Platform not supported!
	#endif

	// create 320x200x8 surface
	small_screen = SDL_CreateRGBSurface(SDL_SWSURFACE, 320, 200, 8, 0, 0, 0, 0);
	SDL_SetPalette(small_screen, SDL_LOGPAL, (SDL_Color *)pal256, 0, 256);

	// Hide the cursor
	SDL_ShowCursor(SDL_DISABLE);

	return 1;
}

void LM_GFX_Deinit()
{
	//SDL_Quit();
}

/*
	The idea taken from http://tech-algorithm.com/articles/bilinear-image-scaling/

	Adapted it from java to c and from float to int

	args: source pixels 320x200x8, dest pixels 480x272x16 (400x240x16), source w & h, dest w & h
*/
void upscale_bilinear(unsigned char *pixels, unsigned short *temp, int w, int h, int w2, int h2)
{
	int x, y, index;
	int x_ratio = ((w-1)*256)/w2; // 664
	int y_ratio = ((h-1)*256)/h2; // 731

	int offset = 0;

	for (int i = 0; i < h2; i++)
		for (int j = 0; j < w2; j++)
		{
			int a, b, c, d;
			int blue, red, green;
			int x_diff, y_diff;

			x = (x_ratio * j) / 256; // 21
			y = (y_ratio * i) / 256; // 24
			x_diff = (x_ratio * j) & 255; // 912
			y_diff = (y_ratio * i) & 255; // 123
			index = (y*w+x);

			a = *(int *)&pal256[pixels[index]*4];
			b = *(int *)&pal256[pixels[index+1]*4];
			c = *(int *)&pal256[pixels[index+w]*4];
			d = *(int *)&pal256[pixels[index+w+1]*4];

			#define R(z) (((z >> 0) & 0xff))
			#define G(z) (((z >> 8) & 0xff))
			#define B(z) (((z >> 16) & 0xff))

			// blue element
			// Yb = Ab(1-w)(1-h) + Bb(w)(1-h) + Cb(h)(1-w) + Db(wh)
			blue = B(a) * (256 - x_diff) * (256 - y_diff) + B(b) * (x_diff) * (256 - y_diff) +
				   B(c) * (y_diff) 	   * (256 - x_diff) + B(d) * (x_diff  * y_diff);

			// green element
			// Yg = Ag(1-w)(1-h) + Bg(w)(1-h) + Cg(h)(1-w) + Dg(wh)
			green = G(a) * (256 - x_diff) * (256 - y_diff) + G(b) * (x_diff) * (256 - y_diff) +
					G(c) * (y_diff)	 * (256 - x_diff) + G(d) * (x_diff  * y_diff);

			// red element
			// Yr = Ar(1-w)(1-h) + Br(w)(1-h) + Cr(h)(1-w) + Dr(wh)
			red = R(a) * (256 - x_diff) * (256 - y_diff) + R(b) * (x_diff) * (256 - y_diff) +
				  R(c) * (y_diff)	 * (256 - x_diff) + R(d) * (x_diff  * y_diff);

			#undef R
			#undef G
			#undef B

			red >>= 16;
			green >>= 16;
			blue >>= 16;


			temp[offset++] =
					((red << 8) & (0x1f << 11)) |
					((green << 3) & (0x3f << 5)) |
					((blue >> 3) & (0x1f << 0));
		}


}
/*
	The idea taken from http://www.compuphase.com/graphic/scale.htm

	args: source pixels 320x200x8, dest pixels 480x272x16 (400x240x16), source w & h, dest w & h
*/
void upscale_bresenham(unsigned char *pixels, unsigned short *temp, int w, int h, int w2, int h2)
{
	int midw = w2 >> 1;
	int midh = h2 >> 1;
	int Ew = 0;
	int Eh = 0;
	int source = 0, target = 0;
	int dh = 0;

	for (int i = 0; i < h2; i++)
	{
		Ew = 0;
		source = dh * w;

		for (int j = 0; j < w2; j++)
		{
			int c;

			__builtin_prefetch(temp + target, 1);

			c = pal565[pixels[source]];

			#define AVERAGE(z, x) ((((z) & 0xF7DE) >> 1) + (((x) & 0xF7DE) >> 1))
			if(Ew >= midw) { // average + 1
				c = AVERAGE(c, pal565[pixels[source+1]]);
			}
			if(Eh >= midh) { // average + w
				c = AVERAGE(c, pal565[pixels[source+w]]);
			}
			#undef AVERAGE
			temp[target++] = c;

			Ew += w; if(Ew >= w2) { Ew -= w2; source += 1; }

		}
		Eh += h; if(Eh >= h2) { Eh -= h2; dh++; }
	}
}

void LM_GFX_Flip(unsigned char *p)
{

	// convert from 320x200x8 to 320x240x16

	// if any Dingux incarnation
	#if defined(__DINGUX__)

	// bilinear or bresenham scaling
	if(StretchFullScreen == 2)
	{
		if(SDL_MUSTLOCK(screen)) SDL_LockSurface(screen);
		upscale_bilinear(p, (unsigned short *)screen->pixels, 320, 200, VModes[VMode].x, VModes[VMode].y);
		if(SDL_MUSTLOCK(screen)) SDL_UnlockSurface(screen);
	}
	else
	if(StretchFullScreen == 1)
	{
		if(SDL_MUSTLOCK(screen)) SDL_LockSurface(screen);
		upscale_bresenham(p, (unsigned short *)screen->pixels, 320, 200, VModes[VMode].x, VModes[VMode].y);
		if(SDL_MUSTLOCK(screen)) SDL_UnlockSurface(screen);
	}
	else
	{
		SDL_Rect dstrect;

		// center windows
		dstrect.x = (VModes[VMode].x - 320) / 2;
		dstrect.y = (VModes[VMode].y - 200) / 2;

		SDL_BlitSurface(small_screen, 0, screen, &dstrect);
	}

	// if Dingoo OS Native
	#elif defined(__DINGOO__)
	{
		SDL_Rect dstrect;

		dstrect.x = 0;
		dstrect.y = 20;

		SDL_BlitSurface(small_screen, 0, screen, &dstrect);
	}
	#else
	#error Platform not supported!
	#endif

	// Update Screen
	SDL_Flip(screen);
}

void LM_GFX_WaitVSync()
{
	// do nothing
}

void LM_GFX_SetScale(int param)
{
	// do nothing
}

// palette in hardware rgba mode
unsigned char pal256[1024] = {
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0x00,
	 0xAA, 0x00, 0x00, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x55, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0x00,
	 0x55, 0x55, 0x55, 0x00, 0x55, 0x55, 0xFF, 0x00, 0x55, 0xFF, 0x55, 0x00, 0x55, 0xFF, 0xFF, 0x00,
	 0xFF, 0x55, 0x55, 0x00, 0xFF, 0x55, 0xFF, 0x00, 0xFF, 0xFF, 0x55, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x14, 0x00, 0x20, 0x20, 0x20, 0x00, 0x2C, 0x2C, 0x2C, 0x00,
	 0x38, 0x38, 0x38, 0x00, 0x44, 0x44, 0x44, 0x00, 0x50, 0x50, 0x50, 0x00, 0x61, 0x61, 0x61, 0x00,
	 0x71, 0x71, 0x71, 0x00, 0x81, 0x81, 0x81, 0x00, 0x91, 0x91, 0x91, 0x00, 0xA1, 0xA1, 0xA1, 0x00,
	 0xB6, 0xB6, 0xB6, 0x00, 0xCA, 0xCA, 0xCA, 0x00, 0xE2, 0xE2, 0xE2, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	 0x00, 0x00, 0xFF, 0x00, 0x40, 0x00, 0xFF, 0x00, 0x7D, 0x00, 0xFF, 0x00, 0xBE, 0x00, 0xFF, 0x00,
	 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xBE, 0x00, 0xFF, 0x00, 0x7D, 0x00, 0xFF, 0x00, 0x40, 0x00,
	 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x40, 0x00, 0x00, 0xFF, 0x7D, 0x00, 0x00, 0xFF, 0xBE, 0x00, 0x00,
	 0xFF, 0xFF, 0x00, 0x00, 0xBE, 0xFF, 0x00, 0x00, 0x7D, 0xFF, 0x00, 0x00, 0x40, 0xFF, 0x00, 0x00,
	 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x40, 0x00, 0x00, 0xFF, 0x7D, 0x00, 0x00, 0xFF, 0xBE, 0x00,
	 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xBE, 0xFF, 0x00, 0x00, 0x7D, 0xFF, 0x00, 0x00, 0x40, 0xFF, 0x00,
	 0x7D, 0x7D, 0xFF, 0x00, 0x9D, 0x7D, 0xFF, 0x00, 0xBE, 0x7D, 0xFF, 0x00, 0xDE, 0x7D, 0xFF, 0x00,
	 0xFF, 0x7D, 0xFF, 0x00, 0xFF, 0x7D, 0xDE, 0x00, 0xFF, 0x7D, 0xBE, 0x00, 0xFF, 0x7D, 0x9D, 0x00,
	 0xFF, 0x7D, 0x7D, 0x00, 0xFF, 0x9D, 0x7D, 0x00, 0xFF, 0xBE, 0x7D, 0x00, 0xFF, 0xDE, 0x7D, 0x00,
	 0xFF, 0xFF, 0x7D, 0x00, 0xDE, 0xFF, 0x7D, 0x00, 0xBE, 0xFF, 0x7D, 0x00, 0x9D, 0xFF, 0x7D, 0x00,
	 0x7D, 0xFF, 0x7D, 0x00, 0x7D, 0xFF, 0x9D, 0x00, 0x7D, 0xFF, 0xBE, 0x00, 0x7D, 0xFF, 0xDE, 0x00,
	 0x7D, 0xFF, 0xFF, 0x00, 0x7D, 0xDE, 0xFF, 0x00, 0x7D, 0xBE, 0xFF, 0x00, 0x7D, 0x9D, 0xFF, 0x00,
	 0xB6, 0xB6, 0xFF, 0x00, 0xC6, 0xB6, 0xFF, 0x00, 0xDA, 0xB6, 0xFF, 0x00, 0xEA, 0xB6, 0xFF, 0x00,
	 0xFF, 0xB6, 0xFF, 0x00, 0xFF, 0xB6, 0xEA, 0x00, 0xFF, 0xB6, 0xDA, 0x00, 0xFF, 0xB6, 0xC6, 0x00,
	 0xFF, 0xB6, 0xB6, 0x00, 0xFF, 0xC6, 0xB6, 0x00, 0xFF, 0xDA, 0xB6, 0x00, 0xFF, 0xEA, 0xB6, 0x00,
	 0xFF, 0xFF, 0xB6, 0x00, 0xEA, 0xFF, 0xB6, 0x00, 0xDA, 0xFF, 0xB6, 0x00, 0xC6, 0xFF, 0xB6, 0x00,
	 0xB6, 0xFF, 0xB6, 0x00, 0xB6, 0xFF, 0xC6, 0x00, 0xB6, 0xFF, 0xDA, 0x00, 0xB6, 0xFF, 0xEA, 0x00,
	 0xB6, 0xFF, 0xFF, 0x00, 0xB6, 0xEA, 0xFF, 0x00, 0xB6, 0xDA, 0xFF, 0x00, 0xB6, 0xC6, 0xFF, 0x00,
	 0x00, 0x00, 0x71, 0x00, 0x1C, 0x00, 0x71, 0x00, 0x38, 0x00, 0x71, 0x00, 0x55, 0x00, 0x71, 0x00,
	 0x71, 0x00, 0x71, 0x00, 0x71, 0x00, 0x55, 0x00, 0x71, 0x00, 0x38, 0x00, 0x71, 0x00, 0x1C, 0x00,
	 0x71, 0x00, 0x00, 0x00, 0x71, 0x1C, 0x00, 0x00, 0x71, 0x38, 0x00, 0x00, 0x71, 0x55, 0x00, 0x00,
	 0x71, 0x71, 0x00, 0x00, 0x55, 0x71, 0x00, 0x00, 0x38, 0x71, 0x00, 0x00, 0x1C, 0x71, 0x00, 0x00,
	 0x00, 0x71, 0x00, 0x00, 0x00, 0x71, 0x1C, 0x00, 0x00, 0x71, 0x38, 0x00, 0x00, 0x71, 0x55, 0x00,
	 0x00, 0x71, 0x71, 0x00, 0x00, 0x55, 0x71, 0x00, 0x00, 0x38, 0x71, 0x00, 0x00, 0x1C, 0x71, 0x00,
	 0x38, 0x38, 0x71, 0x00, 0x44, 0x38, 0x71, 0x00, 0x55, 0x38, 0x71, 0x00, 0x61, 0x38, 0x71, 0x00,
	 0x71, 0x38, 0x71, 0x00, 0x71, 0x38, 0x61, 0x00, 0x71, 0x38, 0x55, 0x00, 0x71, 0x38, 0x44, 0x00,
	 0x71, 0x38, 0x38, 0x00, 0x71, 0x44, 0x38, 0x00, 0x71, 0x55, 0x38, 0x00, 0x71, 0x61, 0x38, 0x00,
	 0x71, 0x71, 0x38, 0x00, 0x61, 0x71, 0x38, 0x00, 0x55, 0x71, 0x38, 0x00, 0x44, 0x71, 0x38, 0x00,
	 0x38, 0x71, 0x38, 0x00, 0x38, 0x71, 0x44, 0x00, 0x38, 0x71, 0x55, 0x00, 0x38, 0x71, 0x61, 0x00,
	 0x38, 0x71, 0x71, 0x00, 0x38, 0x61, 0x71, 0x00, 0x38, 0x55, 0x71, 0x00, 0x38, 0x44, 0x71, 0x00,
	 0x50, 0x50, 0x71, 0x00, 0x59, 0x50, 0x71, 0x00, 0x61, 0x50, 0x71, 0x00, 0x69, 0x50, 0x71, 0x00,
	 0x71, 0x50, 0x71, 0x00, 0x71, 0x50, 0x69, 0x00, 0x71, 0x50, 0x61, 0x00, 0x71, 0x50, 0x59, 0x00,
	 0x71, 0x50, 0x50, 0x00, 0x71, 0x59, 0x50, 0x00, 0x71, 0x61, 0x50, 0x00, 0x71, 0x69, 0x50, 0x00,
	 0x71, 0x71, 0x50, 0x00, 0x69, 0x71, 0x50, 0x00, 0x61, 0x71, 0x50, 0x00, 0x59, 0x71, 0x50, 0x00,
	 0x50, 0x71, 0x50, 0x00, 0x50, 0x71, 0x59, 0x00, 0x50, 0x71, 0x61, 0x00, 0x50, 0x71, 0x69, 0x00,
	 0x50, 0x71, 0x71, 0x00, 0x50, 0x69, 0x71, 0x00, 0x50, 0x61, 0x71, 0x00, 0x50, 0x59, 0x71, 0x00,
	 0x00, 0x00, 0x40, 0x00, 0x10, 0x00, 0x40, 0x00, 0x20, 0x00, 0x40, 0x00, 0x30, 0x00, 0x40, 0x00,
	 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x30, 0x00, 0x40, 0x00, 0x20, 0x00, 0x40, 0x00, 0x10, 0x00,
	 0x40, 0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x40, 0x30, 0x00, 0x00,
	 0x40, 0x40, 0x00, 0x00, 0x30, 0x40, 0x00, 0x00, 0x20, 0x40, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00,
	 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x40, 0x30, 0x00,
	 0x00, 0x40, 0x40, 0x00, 0x00, 0x30, 0x40, 0x00, 0x00, 0x20, 0x40, 0x00, 0x00, 0x10, 0x40, 0x00,
	 0x20, 0x20, 0x40, 0x00, 0x28, 0x20, 0x40, 0x00, 0x30, 0x20, 0x40, 0x00, 0x38, 0x20, 0x40, 0x00,
	 0x40, 0x20, 0x40, 0x00, 0x40, 0x20, 0x38, 0x00, 0x40, 0x20, 0x30, 0x00, 0x40, 0x20, 0x28, 0x00,
	 0x40, 0x20, 0x20, 0x00, 0x40, 0x28, 0x20, 0x00, 0x40, 0x30, 0x20, 0x00, 0x40, 0x38, 0x20, 0x00,
	 0x40, 0x40, 0x20, 0x00, 0x38, 0x40, 0x20, 0x00, 0x30, 0x40, 0x20, 0x00, 0x28, 0x40, 0x20, 0x00,
	 0x20, 0x40, 0x20, 0x00, 0x20, 0x40, 0x28, 0x00, 0x20, 0x40, 0x30, 0x00, 0x20, 0x40, 0x38, 0x00,
	 0x20, 0x40, 0x40, 0x00, 0x20, 0x38, 0x40, 0x00, 0x20, 0x30, 0x40, 0x00, 0x20, 0x28, 0x40, 0x00,
	 0x2C, 0x2C, 0x40, 0x00, 0x30, 0x2C, 0x40, 0x00, 0x34, 0x2C, 0x40, 0x00, 0x3C, 0x2C, 0x40, 0x00,
	 0x40, 0x2C, 0x40, 0x00, 0x40, 0x2C, 0x3C, 0x00, 0x40, 0x2C, 0x34, 0x00, 0x40, 0x2C, 0x30, 0x00,
	 0x40, 0x2C, 0x2C, 0x00, 0x40, 0x30, 0x2C, 0x00, 0x40, 0x34, 0x2C, 0x00, 0x40, 0x3C, 0x2C, 0x00,
	 0x40, 0x40, 0x2C, 0x00, 0x3C, 0x40, 0x2C, 0x00, 0x34, 0x40, 0x2C, 0x00, 0x30, 0x40, 0x2C, 0x00,
	 0x2C, 0x40, 0x2C, 0x00, 0x2C, 0x40, 0x30, 0x00, 0x2C, 0x40, 0x34, 0x00, 0x2C, 0x40, 0x3C, 0x00,
	 0x2C, 0x40, 0x40, 0x00, 0x2C, 0x3C, 0x40, 0x00, 0x2C, 0x34, 0x40, 0x00, 0x2C, 0x30, 0x40, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned short pal565[] = {
	0x0, 0x15, 0x540, 0x555, 0xA800, 0xA815, 0xAAA0, 0xAD55, 0x52AA, 0x52BF, 0x57EA, 0x57FF, 0xFAAA, 
	0xFABF, 0xFFEA, 0xFFFF, 0x0, 0x10A2, 0x2104, 0x2965, 0x39C7, 0x4228, 0x528A, 0x630C, 0x738E, 0x8410, 
	0x9492, 0xA514, 0xB5B6, 0xCE59, 0xE71C, 0xFFFF, 0x1F, 0x401F, 0x781F, 0xB81F, 0xF81F, 0xF817, 0xF80F, 
	0xF808, 0xF800, 0xFA00, 0xFBE0, 0xFDE0, 0xFFE0, 0xBFE0, 0x7FE0, 0x47E0, 0x7E0, 0x7E8, 0x7EF, 0x7F7, 
	0x7FF, 0x5FF, 0x3FF, 0x21F, 0x7BFF, 0x9BFF, 0xBBFF, 0xDBFF, 0xFBFF, 0xFBFB, 0xFBF7, 0xFBF3, 0xFBEF, 
	0xFCEF, 0xFDEF, 0xFEEF, 0xFFEF, 0xDFEF, 0xBFEF, 0x9FEF, 0x7FEF, 0x7FF3, 0x7FF7, 0x7FFB, 0x7FFF, 0x7EFF, 
	0x7DFF, 0x7CFF, 0xB5BF, 0xC5BF, 0xDDBF, 0xEDBF, 0xFDBF, 0xFDBD, 0xFDBB, 0xFDB8, 0xFDB6, 0xFE36, 0xFED6, 
	0xFF56, 0xFFF6, 0xEFF6, 0xDFF6, 0xC7F6, 0xB7F6, 0xB7F8, 0xB7FB, 0xB7FD, 0xB7FF, 0xB75F, 0xB6DF, 0xB63F, 
	0xE, 0x180E, 0x380E, 0x500E, 0x700E, 0x700A, 0x7007, 0x7003, 0x7000, 0x70E0, 0x71C0, 0x72A0, 0x7380, 
	0x5380, 0x3B80, 0x1B80, 0x380, 0x383, 0x387, 0x38A, 0x38E, 0x2AE, 0x1CE, 0xEE, 0x39CE, 0x41CE, 
	0x51CE, 0x61CE, 0x71CE, 0x71CC, 0x71CA, 0x71C8, 0x71C7, 0x7227, 0x72A7, 0x7307, 0x7387, 0x6387, 0x5387, 
	0x4387, 0x3B87, 0x3B88, 0x3B8A, 0x3B8C, 0x3B8E, 0x3B0E, 0x3AAE, 0x3A2E, 0x528E, 0x5A8E, 0x628E, 0x6A8E, 
	0x728E, 0x728D, 0x728C, 0x728B, 0x728A, 0x72CA, 0x730A, 0x734A, 0x738A, 0x6B8A, 0x638A, 0x5B8A, 0x538A, 
	0x538B, 0x538C, 0x538D, 0x538E, 0x534E, 0x530E, 0x52CE, 0x8, 0x1008, 0x2008, 0x3008, 0x4008, 0x4006, 
	0x4004, 0x4002, 0x4000, 0x4080, 0x4100, 0x4180, 0x4200, 0x3200, 0x2200, 0x1200, 0x200, 0x202, 0x204, 
	0x206, 0x208, 0x188, 0x108, 0x88, 0x2108, 0x2908, 0x3108, 0x3908, 0x4108, 0x4107, 0x4106, 0x4105, 
	0x4104, 0x4144, 0x4184, 0x41C4, 0x4204, 0x3A04, 0x3204, 0x2A04, 0x2204, 0x2205, 0x2206, 0x2207, 0x2208, 
	0x21C8, 0x2188, 0x2148, 0x2968, 0x3168, 0x3168, 0x3968, 0x4168, 0x4167, 0x4166, 0x4166, 0x4165, 0x4185, 
	0x41A5, 0x41E5, 0x4205, 0x3A05, 0x3205, 0x3205, 0x2A05, 0x2A06, 0x2A06, 0x2A07, 0x2A08, 0x29E8, 0x29A8
};
